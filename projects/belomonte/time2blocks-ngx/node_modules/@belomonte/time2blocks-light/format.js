"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Time2BlocksFormat = void 0;
const calc_js_1 = require("calc-js");
const util_1 = require("./util");
const calc_config_1 = require("./calc-config");
/**
 * Format blocks
 *
 * @param block
 * the block to be formatted
 *
 * @param format
 * h - current halving
 * H - next halving
 * -h - last halving
 * B - all blocks
 * BB - All blocks in format 0,000,000
 * b - blocks in this halving
 * bb - blocks in this halving in format 000,000
 * -b - blocks to next halving
 * -bb - blocks to next halving in format 000,000
 *
 * % - blocks in this halving in percentage: 0.0% ~ 100.0%,
 * %% - blocks in this halving in percentage: 0.00% ~ 100.00%,
 * %%% - blocks in this halving in percentage: 0.000% ~ 100.000%,
 * %%%% - blocks in this halving in raw percentage: 0.x ~ 100.x%, 65.4234234234234%, 21.5%
 *
 * -% - blocks to next halving in percentage: 0.0% ~ 100.0%,
 * -%% - blocks to next halving in percentage: 0.00% ~ 100.00%,
 * -%%% - blocks to next halving in percentage: 0.000% ~ 100.000%,
 * -%%%% - blocks to next halving in raw percentage: 0.x ~ 100.x%, 65.4234234234234%, 21.5%
 *
 * So, if your format string include the letter h, b or B you should escape this:
 * blocksFormat(80000, 'h [Halvings], [block] bb') will return: 3 Halvings, block 170,000
 * blocksFormat(80000, 'h [[Halvings]], [[block]] bb') will return: 3 Halvings, block 170,000
 */
class Time2BlocksFormat {
    static getInstance(newInstance) {
        if (!this.instance) {
            this.instance = newInstance || new Time2BlocksFormat();
        }
        return this.instance;
    }
    constructor() {
        return Time2BlocksFormat.getInstance(this);
    }
    format(block, format, numberSeparator = ',') {
        const thisHalvingBlock = this.getThisHalvingBlocks(block);
        let formatted = this.formatHalvings(block, format);
        formatted = this.formatBlocksToNextHalving(thisHalvingBlock, formatted);
        formatted = this.formatBlocksInThisHalving(thisHalvingBlock, formatted);
        formatted = this.formatTotalBlocks(block, formatted);
        formatted = this.formatBlocksInThisHalvingWithCommas(thisHalvingBlock, formatted, numberSeparator);
        formatted = this.formatPercentInThisHalving(thisHalvingBlock, formatted);
        formatted = this.formatTotalBlocksWithCommas(block, formatted, numberSeparator);
        formatted = this.removeEscapeBrackets(formatted);
        return formatted;
    }
    getHalvingFromBlocks(block) {
        return new calc_js_1.Calc(block, calc_config_1.calcConfig)
            .divide(util_1.Time2BlocksUtil.blocksPerHalving)
            .pipe(v => Math.floor(v))
            .finish();
    }
    formatHalvings(block, format) {
        const halving = this.getHalvingFromBlocks(block);
        if (util_1.Time2BlocksUtil.hasLastHalving.test(format)) {
            const lastHalving = halving - 1;
            format = format.replace(util_1.Time2BlocksUtil.hasLastHalving, String(lastHalving < 0 ? 0 : lastHalving));
        }
        if (util_1.Time2BlocksUtil.hasHalving.test(format)) {
            format = format.replace(util_1.Time2BlocksUtil.hasHalving, String(halving));
        }
        if (util_1.Time2BlocksUtil.hasNextHalving.test(format)) {
            format = format.replace(util_1.Time2BlocksUtil.hasNextHalving, String(halving + 1));
        }
        return format;
    }
    formatBlocksToNextHalving(block, format) {
        const toNextHalving = String(new calc_js_1.Calc(util_1.Time2BlocksUtil.blocksPerHalving).minus(block).finish());
        if (util_1.Time2BlocksUtil.hasMinusbb.test(format)) {
            format = format.replace(util_1.Time2BlocksUtil.hasMinusbb, toNextHalving);
        }
        if (util_1.Time2BlocksUtil.hasMinusb.test(format)) {
            format = format.replace(util_1.Time2BlocksUtil.hasMinusb, toNextHalving);
        }
        return format;
    }
    formatBlocksInThisHalving(block, format) {
        if (util_1.Time2BlocksUtil.hasb.test(format)) {
            format = format.replace(util_1.Time2BlocksUtil.hasb, String(block));
        }
        return format;
    }
    formatBlocksInThisHalvingWithCommas(block, format, numberSeparator) {
        if (util_1.Time2BlocksUtil.hasbb.test(format)) {
            format = format.replace(util_1.Time2BlocksUtil.hasbb, String(block).replace(util_1.Time2BlocksUtil.formatNumberWithSeparator, numberSeparator));
        }
        return format;
    }
    formatTotalBlocks(block, format) {
        if (util_1.Time2BlocksUtil.hasB.test(format)) {
            format = format.replace(util_1.Time2BlocksUtil.hasB, String(block));
        }
        return format;
    }
    formatTotalBlocksWithCommas(block, format, numberSeparator) {
        if (util_1.Time2BlocksUtil.hasBB.test(format)) {
            format = format.replace(util_1.Time2BlocksUtil.hasBB, String(block).replace(util_1.Time2BlocksUtil.formatNumberWithSeparator, numberSeparator));
        }
        return format;
    }
    getThisHalvingBlocks(block) {
        const halving = this.getHalvingFromBlocks(block);
        //  blocksInThisHalving = blocks - (halving / 210_000)
        return new calc_js_1.Calc(block, calc_config_1.calcConfig).minus(new calc_js_1.Calc(halving, calc_config_1.calcConfig)
            .multiply(util_1.Time2BlocksUtil.blocksPerHalving)
            .finish()).finish();
    }
    formatPercentInThisHalving(thisHalvingBlock, format) {
        const fullPercent = 100;
        //  rawPercent = thisHalvingBlock / 210_000
        const rawPercent = new calc_js_1.Calc(thisHalvingBlock, calc_config_1.calcConfig)
            .divide(util_1.Time2BlocksUtil.blocksPerHalving)
            .multiply(fullPercent)
            .finish();
        [
            util_1.Time2BlocksUtil.hasNextHalvingPercent4, util_1.Time2BlocksUtil.hasNextHalvingPercent3,
            util_1.Time2BlocksUtil.hasNextHalvingPercent2, util_1.Time2BlocksUtil.hasNextHalvingPercent,
            util_1.Time2BlocksUtil.hasThisHalvingPercent4, util_1.Time2BlocksUtil.hasThisHalvingPercent3,
            util_1.Time2BlocksUtil.hasThisHalvingPercent2, util_1.Time2BlocksUtil.hasThisHalvingPercent
        ].forEach(hasPercentIndex => {
            if (hasPercentIndex.test(format)) {
                format = format.replace(hasPercentIndex, `[${this.formatPercent(rawPercent, hasPercentIndex)}%]`);
            }
        });
        return format;
    }
    formatPercent(rawPercent, formatType) {
        const decimalBase = util_1.Time2BlocksUtil.decimalBaseMap[String(formatType)] || null;
        const isToNextHalving = util_1.Time2BlocksUtil.isNextHalving[String(formatType)] || false;
        let calc;
        if (isToNextHalving) {
            const fullPercent = 100;
            calc = new calc_js_1.Calc(fullPercent, calc_config_1.calcConfig).minus(rawPercent);
        }
        else {
            calc = new calc_js_1.Calc(rawPercent, calc_config_1.calcConfig);
        }
        if (decimalBase !== null) {
            calc = calc.multiply(decimalBase)
                .pipe(v => Math.floor(v))
                .divide(decimalBase);
        }
        return calc.finish().toString();
    }
    removeEscapeBrackets(formatted) {
        return formatted.replace(/[\[\]]/g, '');
    }
}
exports.Time2BlocksFormat = Time2BlocksFormat;
Time2BlocksFormat.instance = null;
//# sourceMappingURL=format.js.map