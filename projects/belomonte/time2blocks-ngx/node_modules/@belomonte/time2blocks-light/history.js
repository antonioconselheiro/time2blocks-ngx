"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Time2BlockMempoolConn = exports.Time2BlockConnection = exports.WebSocketFacade = exports.Time2BlocksHistoryLoader = void 0;
const calc_js_1 = require("calc-js");
const calc_config_1 = require("./calc-config");
const ws_1 = require("ws");
const base_history_1 = require("./base-history");
class Time2BlocksHistoryLoader {
    static getInstance(isOnline = true, newInstance) {
        if (!this.instance) {
            this.instance = newInstance || new Time2BlocksHistoryLoader(isOnline);
            this.instance.updateHistoryIndex();
            if (isOnline) {
                this.instance.update().then(() => this.instance.listenMempool());
            }
        }
        return this.instance;
    }
    constructor(isOnline = true) {
        this.isOnline = isOnline;
        //  starts with a basic historic for reference
        // ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥
        this.history = base_history_1.baseHistory;
        this.cache = {};
        this.mempoolApi = 'https://mempool.space/api/';
        this.mempoolConn = null;
        this.lastBlock = null;
        this.firstBlock = {
            block: 1, time: '1230983705'
        };
        this.listening = false;
        this.updating = [];
        return Time2BlocksHistoryLoader.getInstance(isOnline, this);
    }
    setIndex(history) {
        this.history = history;
        this.updateHistoryIndex();
    }
    updateIndex(history) {
        this.history = Object.assign(Object.assign({}, this.history), history);
        this.updateHistoryIndex();
    }
    addBlock(block, time) {
        if (!this.lastBlock || block > this.lastBlock.block) {
            this.lastBlock = { block, time };
        }
        this.history[time] = block;
        this.updateHistoryIndex();
    }
    loadIndex(path) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield fetch(path || './history.json');
            this.history = yield response.json();
            this.updateHistoryIndex();
            return Promise.resolve();
        });
    }
    listenMempool() {
        this.listening = true;
        this.mempoolConn = new Time2BlockMempoolConn();
        this.mempoolConn.onBlock(block => this.addBlock(block.height, block.timestamp));
    }
    listen() {
        this.listening = true;
        if (this.mempoolConn) {
            this.mempoolConn.connect();
        }
    }
    stopListen() {
        this.listening = false;
        if (this.mempoolConn) {
            this.mempoolConn.close();
        }
    }
    updateBlockNextToTimestamp(timestamp, start, end) {
        return __awaiter(this, void 0, void 0, function* () {
            const baseHeight = this.getEstimatedBlockFromTimestamp(timestamp, start, end);
            if (this.lastBlock && baseHeight === this.lastBlock.block) {
                return Promise.resolve();
            }
            const response = yield fetch(`${this.mempoolApi}v1/blocks/${baseHeight}`);
            const blocksList = yield response.json();
            blocksList.forEach(({ height, timestamp }) => this.addBlock(Number(height), timestamp));
            this.updateHistoryIndex();
        });
    }
    update() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isOnline) {
                return Promise.resolve();
            }
            const response = yield fetch(`${this.mempoolApi}v1/blocks/`);
            const updaten = yield response.json();
            updaten.forEach(block => this.addBlock(block.height, block.timestamp));
            return Promise.resolve();
        });
    }
    loadBlock(height) {
        return __awaiter(this, void 0, void 0, function* () {
            const responseHash = yield fetch(`${this.mempoolApi}block-height/${height}`);
            const hash = yield responseHash.json();
            const responseBlock = yield fetch(`${this.mempoolApi}block/${hash}`);
            const timestamp = yield responseBlock.json();
            const metadata = { height, timestamp: String(timestamp) };
            this.history[metadata.timestamp] = metadata.height;
            this.updateHistoryIndex();
            return Promise.resolve(metadata);
        });
    }
    updateHistoryIndex() {
        this.timestampKeys = Object.keys(this.history).sort((a, b) => Number(a) - Number(b));
        this.blockKeys = Object.values(this.history).sort((a, b) => a - b);
        this.historyBlockIndexed = Object.fromEntries(Object.entries(this.history).map(([chave, valor]) => [valor, chave]));
    }
    getEstimatedBlockFromTimestamp(timestamp, start, end) {
        const blocksDifference = new calc_js_1.Calc(end.height, calc_config_1.calcConfig).minus(start.height).finish();
        const timeDifference = new calc_js_1.Calc(Number(end.timestamp), calc_config_1.calcConfig)
            .minus(Number(start.timestamp))
            .finish();
        const estimatedTimeForEachBlock = new calc_js_1.Calc(timeDifference, calc_config_1.calcConfig)
            .divide(blocksDifference)
            .pipe(v => Math.floor(v))
            .finish();
        const timeDifferenceBetweenReferenceAndArg = new calc_js_1.Calc(timestamp, calc_config_1.calcConfig)
            .minus(Number(start.timestamp))
            .pipe(v => Math.sqrt(Math.pow(v, 2)))
            .finish();
        const estimatedBlocksFromStartReference = new calc_js_1.Calc(timeDifferenceBetweenReferenceAndArg, calc_config_1.calcConfig)
            .divide(estimatedTimeForEachBlock)
            .pipe(v => Math.floor(v))
            .pipe(v => Math.sqrt(Math.pow(v, 2)))
            .finish();
        const estimationOperation = timestamp > Number(end.timestamp) ? 'minus' : 'sum';
        const estimatedBlock = new calc_js_1.Calc(start.height, calc_config_1.calcConfig)[estimationOperation](estimatedBlocksFromStartReference).finish();
        if (estimatedBlock <= 1) {
            return 1;
        }
        else if (this.lastBlock && estimatedBlock >= this.lastBlock.block) {
            return this.lastBlock.block;
        }
        return estimatedBlock;
    }
    offline() {
        this.isOnline = false;
    }
}
exports.Time2BlocksHistoryLoader = Time2BlocksHistoryLoader;
Time2BlocksHistoryLoader.instance = null;
class WebSocketFacade {
    constructor(conn) {
        this.hasWindow = typeof window !== 'undefined';
        this.init(conn);
    }
    init(conn) {
        if (this.hasWindow) {
            this.clientWeb = new (window.WebSocket || window['MozWebSocket'])(conn);
        }
        else {
            this.clientNode = new ws_1.WebSocket(conn);
        }
    }
    onOpen(calle) {
        if (this.clientWeb) {
            this.clientWeb.onopen = calle;
        }
        else if (this.clientNode) {
            this.clientNode.on('open', calle);
        }
    }
    onError(calle) {
        if (this.clientWeb) {
            this.clientWeb.onerror = calle;
        }
        else if (this.clientNode) {
            this.clientNode.on('error', calle);
        }
    }
    onMessage(calle) {
        if (this.clientWeb) {
            this.clientWeb.onmessage = (ev) => calle(JSON.parse(ev.data));
        }
        else if (this.clientNode) {
            this.clientNode.on('message', (message) => calle(JSON.parse(message)));
        }
    }
    onClose(calle) {
        if (this.clientWeb) {
            this.clientWeb.onclose = calle;
        }
        else if (this.clientNode) {
            this.clientNode.on('close', calle);
        }
    }
    close() {
        if (this.clientWeb) {
            this.clientWeb.close();
        }
        else if (this.clientNode) {
            this.clientNode.close();
        }
    }
    send(serialized) {
        if (this.clientWeb) {
            this.clientWeb.send(serialized);
        }
        else if (this.clientNode) {
            this.clientNode.send(serialized);
        }
    }
}
exports.WebSocketFacade = WebSocketFacade;
class Time2BlockConnection {
    constructor() {
        this.subscriptions = [];
    }
    onBlock(sub) {
        this.subscriptions.push(sub);
    }
    emit(block) {
        this.subscriptions.forEach(calle => calle(block));
    }
}
exports.Time2BlockConnection = Time2BlockConnection;
class Time2BlockMempoolConn extends Time2BlockConnection {
    constructor() {
        super();
        this.link = 'wss://mempool.space/api/v1/ws';
        this.connect();
        this.client.onOpen(() => this.onConnect());
    }
    connect() {
        this.client = new WebSocketFacade(this.link);
    }
    onConnect() {
        this.client.onClose(() => this.onClose());
        this.client.onMessage(packet => {
            if (typeof packet === 'string') {
                packet = JSON.parse(packet);
            }
            this.onMessage(packet);
        });
        this.client.onError(err => console.error('error', err));
        this.blockSubscribe();
    }
    blockSubscribe() {
        this.client.send(JSON.stringify({ "action": "init" }));
        this.client.send(JSON.stringify({ "action": "want", "data": ['blocks'] }));
    }
    onMessage(res) {
        if (res.block) {
            const { height, timestamp } = res.block;
            this.emit({ height, time: String(timestamp) });
        }
        else if (res.blocks) {
            res.blocks.forEach(block => {
                const { height, timestamp } = block;
                this.emit({ height, time: String(timestamp) });
            });
        }
    }
    close() {
        if (this.client) {
            this.client.close();
        }
    }
    onClose() {
        this.client = null;
    }
}
exports.Time2BlockMempoolConn = Time2BlockMempoolConn;
//# sourceMappingURL=history.js.map