"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Time2Blocks = void 0;
const format_1 = require("./format");
const history_1 = require("./history");
__exportStar(require("./format"), exports);
__exportStar(require("./history"), exports);
__exportStar(require("./util"), exports);
class Time2Blocks {
    static getInstance(isOnline = true, newInstance) {
        if (!this.instance) {
            this.instance = newInstance || new Time2Blocks(isOnline);
        }
        return this.instance;
    }
    constructor(isOnline) {
        this.isOnline = isOnline;
        this.loading = null;
        this.formatService = format_1.Time2BlocksFormat.getInstance();
        if (this.isOnline) {
            this.historyService = history_1.Time2BlocksHistoryLoader.getInstance();
        }
        else {
            this.historyService = history_1.Time2BlocksHistoryLoader.getInstance(false);
            this.historyService.offline();
        }
        return Time2Blocks.getInstance(isOnline, this);
    }
    getFromTimestamp(timestamp) {
        return __awaiter(this, void 0, void 0, function* () {
            // macgyverism
            if (this.loading) {
                const loading = this.loading;
                const newLoading = this.loading = new Promise(resolve => {
                    loading.then(() => {
                        return this.loadFromTimestamp(timestamp).then((v) => {
                            if (newLoading === this.loading) {
                                this.loading = null;
                            }
                            resolve(v);
                            return Promise.resolve(v);
                        });
                    });
                });
                return newLoading;
            }
            const newLoading = this.loading = this.loadFromTimestamp(timestamp);
            this.loading.then((v) => {
                if (newLoading === this.loading) {
                    this.loading = null;
                }
                return Promise.resolve(v);
            });
            return newLoading;
        });
    }
    loadFromTimestamp(timestamp) {
        return __awaiter(this, void 0, void 0, function* () {
            let wrapper = this.getBlockFromTimestamp(timestamp);
            if ('block' in wrapper) {
                return Promise.resolve(wrapper.block);
            }
            if (!this.isOnline) {
                return Promise.resolve(null);
            }
            const start = this.getBlockWithDateFromIndexedBlock(wrapper.blockA);
            const end = this.getBlockWithDateFromIndexedBlock(wrapper.blockB);
            yield this.historyService.updateBlockNextToTimestamp(timestamp, start, end);
            wrapper = this.getBlockFromTimestamp(timestamp);
            if ('block' in wrapper) {
                this.historyService.cache[timestamp] = wrapper.block;
                return Promise.resolve(wrapper.block);
            }
            return this.loadFromTimestamp(timestamp);
        });
    }
    getBlockWithDateFromIndexedBlock(indexedBlock) {
        const timestamp = this.historyService.historyBlockIndexed[indexedBlock];
        return { height: indexedBlock, timestamp };
    }
    getBlockFromTimestamp(timestamp) {
        let block = this.historyService.history[timestamp] || this.historyService.cache[timestamp];
        if (block) {
            //  if the timestamp is the exact one indexed
            return { block };
        }
        else if (this.historyService.lastBlock && timestamp >= Number(this.historyService.lastBlock.time)) {
            //  if timestamp is major than the last block creation time
            block = this.historyService.lastBlock.block;
            return { block };
        }
        else if (Number(this.historyService.firstBlock.time) > timestamp) {
            //  if timestamp is minor than the first block creation time
            block = this.historyService.firstBlock.block;
            return { block };
        }
        const timestampKeys = this.historyService.timestampKeys;
        const timeKey = this.getTimeIndexedFromTime(timestamp, [].concat(timestampKeys));
        block = this.historyService.history[timeKey];
        const blockBefore = block - 1;
        const blockAfter = block + 1;
        const isBeforeBlockIndexed = !!this.historyService.historyBlockIndexed[blockBefore];
        const isAfterBlockIndexed = !!this.historyService.historyBlockIndexed[blockAfter];
        //  if there are blocks around this will be surelly the block related to the timestamp,
        //  otherwise would be need to load the data around the given references
        if (isBeforeBlockIndexed && isAfterBlockIndexed) {
            return { block };
        }
        const blockKeys = [].concat(this.historyService.blockKeys);
        if (!isBeforeBlockIndexed) {
            const [blockIndexedBefore, blockIndexedAfter] = this.getIndexedBlocksAroundBlock(blockBefore, blockKeys);
            return { blockA: blockIndexedBefore, blockB: blockIndexedAfter };
        }
        else {
            const [blockIndexedBefore, blockIndexedAfter] = this.getIndexedBlocksAroundBlock(blockAfter, blockKeys);
            return { blockA: blockIndexedBefore, blockB: blockIndexedAfter };
        }
    }
    format(block, format, numberSeparator = ',') {
        return this.formatService.format(block, format, numberSeparator);
    }
    /**
     * using the timestamp passed by parameter, it searches the indexed timestamps,
     * those with the associated block number, and then delivers the timestamp
     * closest to the parameter that is indexed
     *
     * @param timestamp reference
     * @param times array with all indexed timestamp
     *
     * @returns indexed timestamp closest to the timestamp parameter
     */
    getTimeIndexedFromTime(timestamp, times) {
        if (times.length === 1) {
            return Number(times[0]);
        }
        const middle = Math.floor(times.length / 2);
        const timesClone = [].concat(times);
        const blocksBefore = timesClone.splice(0, middle);
        const blocksAfter = timesClone;
        const majorTimeFromBeforeList = blocksBefore[blocksBefore.length - 1];
        const minorTimeFromAfterList = blocksAfter[0];
        if (majorTimeFromBeforeList < timestamp && timestamp < minorTimeFromAfterList) {
            return minorTimeFromAfterList;
        }
        else if (Number(times[middle]) < timestamp) {
            return this.getTimeIndexedFromTime(timestamp, blocksAfter);
        }
        else {
            return this.getTimeIndexedFromTime(timestamp, blocksBefore);
        }
    }
    getIndexedBlocksAroundBlock(requestedBlock, blocks) {
        if (blocks.length === 1) {
            return [blocks[0], blocks[0]];
        }
        const blocksClone = [].concat(blocks);
        const middle = Math.floor(blocks.length / 2);
        const blocksBeforeMiddle = blocksClone.splice(0, middle);
        const blocksAfterMiddle = blocksClone;
        const blockInMiddle = Number(blocks[middle]);
        const majorBlockFromBeforeBlocks = blocksBeforeMiddle[blocksBeforeMiddle.length - 1];
        const minorBlockFromAfterBlocks = blocksAfterMiddle[0];
        if (majorBlockFromBeforeBlocks < requestedBlock && requestedBlock < minorBlockFromAfterBlocks) {
            return [majorBlockFromBeforeBlocks, minorBlockFromAfterBlocks];
        }
        else if (requestedBlock < blockInMiddle) {
            return this.getIndexedBlocksAroundBlock(requestedBlock, blocksBeforeMiddle);
        }
        else {
            return this.getIndexedBlocksAroundBlock(requestedBlock, blocksAfterMiddle);
        }
    }
    offline() {
        this.isOnline = false;
        this.historyService.offline();
    }
}
exports.Time2Blocks = Time2Blocks;
Time2Blocks.instance = null;
//# sourceMappingURL=index.js.map